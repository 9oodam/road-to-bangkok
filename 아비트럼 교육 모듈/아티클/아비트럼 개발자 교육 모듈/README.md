# 아비트럼 개발자 교육 모듈

  ## 아비트럼 네트워크 탄생 배경 및 현황 개요

블록체인과 웹3 기술의 급속한 발전으로 확장성 문제가 업계의 핵심 과제로
대두되었다. 이러한 맥락에서 2020년, 이더리움 생태계는 중대한 전환점을
맞이했다. 비탈릭 부테린을 포함한 이더리움 핵심 개발자들이 \'롤업 중심의
로드맵\'이라는 새로운 비전을 제시했고, 이는 블록체인 업계에 상당한
파장을 일으켰다.

롤업 기술은 메인 체인의 보안성을 유지하면서도 처리 속도와 확장성을
획기적으로 개선할 수 있는 혁신적 해결책으로 주목받았다. 이더리움 재단이
이 방향성을 공식화하면서 아비트럼, 옵티미즘 등 주요 롤업 프로젝트들도
급속히 성장하기 시작했다.

특히 아비트럼은 이더리움의 비전에 발맞춰 선도적으로 롤업 기술을 개발하고
상용화했다. 아비트럼은 이더리움의 확장성 문제를 해결하기 위해 오프체인
랩스(Offchain Labs)에서 개발한 레이어 2 솔루션이다. 2018년 설립된
오프체인 랩스는 프린스턴 대학의 컴퓨터 과학자들이 주도하여, 학계의 최신
연구 성과를 블록체인 기술에 접목시키고자 했다. 아비트럼의 핵심 기술인
옵티미스틱 롤업은 이더리움의 보안성을 유지하면서도 처리 속도와 비용
효율성을 크게 개선할 수 있는 혁신적인 접근 방식이다.이더리움의 롤업 중심
전략과 아비트럼의 기술력이 시너지를 발휘하면서, 웹3 생태계는 새로운
도약의 기회를 맞이하게 되었다.

이러한 변화는 단순한 기술 혁신을 넘어 블록체인의 대중화를 앞당기는
중요한 전환점이 되었다. 롤업 기술의 도입으로 거래 속도는 향상되고
수수료는 감소했으며, 이는 더 많은 사용자와 개발자들을 블록체인 생태계로
유인하는 계기가 되었다. 2020년부터 시작된 이 \'롤업 혁명\'은 오늘날
웹3의 폭발적인 성장을 이끈 주요 동력 중 하나로 평가받고 있다.

![img3](images/image3.png)

*이더리움 메인넷 내 발생하는 가스비와 레이어 2의 가스비 비교(Source :
l2fees.info)*

아비트럼은 옵티미스틱 롤업 기술을 채택하여, 트랜잭션 처리를 레이어 2에서
수행하고 그 결과만을 주기적으로 이더리움 메인넷에 기록한다. 이 과정에서
트랜잭션의 유효성을 \'낙관적\'으로 가정하고, 문제가 있을 경우 이의제기할
수 있는 기간을 두는 방식을 채택했다. 이를 통해 아비트럼은 이더리움의
보안성을 상속받으면서도, 훨씬 낮은 비용과 높은 처리 속도를 실현할 수
있게 되었다.

**아비트럼의 주요 특징:** 아비트럼은 다음과 같은 특징을 통해 개발자와
사용자들에게 매력적인 플랫폼을 제공한다.

  ## 특징
  **이더리움 호환성** : 기존 이더리움 스마트 컨트랙트와 개발 도구를 그대로
                   사용할 수 있어, 개발자들의 진입 장벽을 낮췄다.

  **높은 확장성** : 이더리움 대비 최대 100배 이상의 처리량을 제공한다.

  **낮은 거래 비용** : 가스비를 이더리움 대비 10\~20배 가량 절감할 수 있다.

  **강력한 보안성** : 이더리움의 보안 모델을 그대로 활용하여 높은 수준의
                   안전성을 보장한다.


아비트럼의 성장과 생태계: 아비트럼은 출시 이후 급속한 성장을 보이며,
레이어 2 솔루션 중 가장 큰 생태계를 구축했다. 2024년 현재 전체 롤업
TVL의 42% 이상을 차지하고 있으며, 560개 이상의 DApp이 온보딩되어 있다.
아베(Aave), 유니스왑(Uniswap) 등 대형 DeFi 프로젝트부터 최신 트렌드의
애플리케이션까지 다양한 서비스가 아비트럼 위에서 운영되고 있다.

## 롤업과 트랜잭션 라이프 사이클

1)  **Roll Up**

아비트럼의 롤업 프로토콜은 레이어 2 솔루션의 핵심 기술로, 이더리움의
확장성 문제를 해결하는 데 중요한 역할을 한다. 일반 사용자나 개발자가 이
프로토콜의 내부 작동 원리를 자세히 알 필요는 없지만, 기본적인 이해는
아비트럼 생태계에서 개발을 시작하는 데 도움이 될 수 있다.

아비트럼은 '옵티미스틱 롤업\'이라는 레이어 2 확장 솔루션을 채택했다. 이
방식의 핵심은 모든 트랜잭션을 일단 유효하다고 가정하고 처리한 뒤, 나중에
문제가 있다면 이의를 제기할 수 있도록 하는 것이다. 구체적으로,
아비트럼은 모든 트랜잭션 데이터를 이더리움 메인넷에 \'콜데이터\'로
기록한다. 이렇게 하면 누구나 체인의 현재 상태를 확인하고 검증할 수
있는데, 새로운 블록이 제안되면 약 일주일 동안의 이의 제기 기간을 두며 이
기간 동안 누구든 해당 블록의 유효성에 의문을 제기할 수 있다.

만약 문제가 제기되면, 아비트럼은 \'대화형 사기 증명\'이라는 독특한
방식으로 이를 해결한다. 이 방식은 양측이 단계적으로 문제를 좁혀가다가
최종적으로 단 하나의 실행 단계에 대해서만 이더리움 메인넷에서 검증하는
방식이다. 이 접근법의 장점은 여러 가지다. 우선, 정상적인 상황에서는
메인넷에 최소한의 데이터만 기록하면 되므로 가스 비용을 크게 줄일 수
있다. 또한, 이 방식은 더 복잡한 트랜잭션도 처리할 수 있어 이더리움의
가스 한도를 넘어서는 작업도 가능하게 만든다. 게다가 메인넷의 부담을
최소화하면서도 높은 처리량을 달성할 수 있어 확장성 측면에서도 큰 이점이
있다. 결과적으로 이러한 옵티미스틱 롤업 방식은 아비트럼이 효율적이고
안전한 레이어 2 솔루션으로 자리잡는 데 핵심적인 역할을 했다. 이 방식은
대부분의 경우 트랜잭션이 올바르다고 낙관적으로 가정하면서도, 필요할 때
강력한 검증 메커니즘을 제공하는 균형 잡힌 해결책이라고 볼 수 있다.

롤업 프로토콜의 주요 목적은 트랜잭션 결과를 확인하는 것이다. 트랜잭션의
실제 결과는 체인의 인박스에 있는 메시지 시퀀스에 의해 결정되며, 롤업
프로토콜은 이 결과를 이더리움 메인넷에 안전하게 기록하는 역할을 한다.
이는 두 가지 중요한 이유로 필요하다. 첫째, 누군가가 결과에 대해 거짓말을
할 수 있으므로 신뢰 없는 방식으로 진실을 확인해야 한다. 둘째, 이더리움은
모든 아비트럼 트랜잭션을 직접 모니터링할 수 없기 때문에, 확인된 결과에
의존하여 L1으로의 출금 등의 작업을 처리할 수 있어야 한다.

롤업 프로토콜의 핵심 참여자는 검증자(validator)다. 검증자 중 일부는
스테이커(staker)가 되어 ETH를 예치하고, 정직하게 행동하면 이를 회수할 수
있다. 일반적으로 하나의 검증자만 스테이킹하며, 다른 당사자들의 행동이
필요 없는 한 이 상태가 유지된다. 아비트럼 원에서는 현재
검증자/스테이커가 허용 목록으로 관리되고 있지만, 원칙적으로는 누구나 이
역할을 수행할 수 있다.

롤업 체인은 \'RBlock\'이라 불리는 롤업 블록의 연속으로 구성된다. 이는 L1
이더리움 블록이나 L2 니트로 블록과는 다른, 별도의 체인을 형성한다. 각
RBlock은 블록 번호, 이전 블록 번호, 생성된 L2 블록 수, 처리된 인박스
메시지 수, 그리고 체인 역사상 생성된 출력의 해시를 포함한다.

롤업 체인의 이해를 돕기 위한 예시는 아래와 같다.

![img2](images/image2.png)
보통 롤업 체인은 두 부분으로 나뉜다. 왼쪽에는 이미 확인된 RBlock(블록
번호 91\~94)들이 있는데, 이는 레이어 1 컨트랙트가 인정하고 기록한 체인의
역사다. 이 중 가장 최근에 확인된 RBlock 94을 \"최신 확인 RBlock\"이라고
한다. 오른쪽에는 새로 제안된 RBlock(95\~98)들이 있다. 이들은 아직
확인되지 않았지만, 시간이 지나면 대부분 확인될 것이다.

주목할 만한 점은 새로 제안된 RBlock이 이전에 제안된 RBlock 위에 쌓일 수
있다는 것이다. 이 덕분에 검증자들은 이전 블록의 확인을 기다리지 않고도
계속해서 새 블록을 제안할 수 있어, 체인의 효율성을 크게 높인다.

![img4](images/image4.png)

하지만 악의적인 검증자들이 있으면 체인 상태가 복잡해질 수 있다. 예를
들어, 위 이미지처럼 RBlock 101이 적합한 블록이라고 판단되지 않는다면
블록 제안이 거부된다. 이후 RBlock 102가 올바른 후속블록으로 확인된다.
RBlock 103이 확인되어 최신 확인 RBlock이 되었을 때, 위 이미지처럼
여러개의 블록이 서로가 올바른 후속블록이라 주장하는 경우(RBlock 106,
RBlock 109) 또한 존재한다. 이런 복잡한 상황을 다루기 위해 프로토콜은
세밀한 규칙을 가지고 있다. RBlock들은 번호 순서대로 처리되며, 어떤
블록의 운명은 그 이전 블록의 상태에 따라 결정된다. 이를 통해 프로토콜은
일관성 있고 안정적인 체인 상태를 유지할 수 있다.

실제로 이런 복잡한 상황은 거의 일어나지 않는다. 대부분의 경우 검증자들은
정직하게 행동하고, 체인은 순조롭게 진행된다. 그래도 프로토콜은 최악의
상황에 대비해 설계되어 있어, 어떤 경우에도 체인의 무결성을 지킬 수 있다.

이러한 롤업 프로토콜 설계 덕분에 아비트럼은 높은 확장성과 보안성을
동시에 달성할 수 있다. 개발자들은 이런 탄탄한 기술 기반 위에서 안심하고
자신의 애플리케이션을 만들 수 있다. 실제 개발 과정에서 이런 내부 구조를
직접 다룰 일은 없겠지만, 기본 원리를 이해하면 아비트럼 생태계에서 더
효과적으로 활동하는 데 도움이 될 것이다.

2)  **Transaction LifeCycle**

아비트럼 트랜잭션의 라이프 스케일은 복잡해 보이지만, 단계별로 살펴보면
그 원리를 쉽게 이해할 수 있다. 이 과정을 통해 아비트럼이 어떻게
이더리움의 확장성 문제를 해결하면서도 보안성을 유지하는지 알 수 있다.

트랜잭션은 시퀀서에서 시작된다. 시퀀서는 트랜잭션의 순서를 결정하는
중요한 역할을 하며, 클라이언트가 트랜잭션을 보내면 시퀀서는 이를 두 가지
방법으로 받을 수 있다:

  **직접 전송(오프 체인)** : L2 환경에서 일반적으로 사용되는 방식. 클라이언트가 체인갑을 L2 노드에 연결하고 서명된 트랜잭션을 직접 전송한다.

  **L1을 통한 delayed 전송(Delay Inbox를 통한 전송)** : 클라이언트가 L1 트랜잭션을 아비트럼 체인의 delayed inbox에 서명하여 시퀀서에 메시지를 보내는 방식. 주로 ETH나 토큰을 브릿지를 통해 예치할 때 사용된다.


만약 오프 체인으로 전송받는 방법을 택한다면, 시퀀서가 트랜잭션을 받았을
때 다음과 같은 과정을 거친다:

1.  오프체인 인박스에서 트랜잭션 순서를 정한다.

2.  아비트럼 니트로 VM을 사용해 로컬에서 실행한다 (이 과정에서 L1과 L2
    수수료를 계산하고 할당한다).

3.  클라이언트에게 거의 즉시 트랜잭션 영수증(Transaction receipt)을
    제공한다 (보통 1초 미만, 평균 260ms 정도 소요).

이 단계에서 클라이언트는 시퀀서를 신뢰해야 한다. 이를 \'Soft
Confirmation\'이라고 부른다. 악의적인 시퀀서라도 트랜잭션을 재정렬하거나
일시적으로 지연시킬 수 있을 뿐, 위조하거나 잘못된 상태 업데이트를 제안할
수는 없다.

다음으로, 시퀀서는 클라이언트의 트랜잭션을 포함한 L2 트랜잭션 배치를
L1에 게시한다. 보통 몇 분 간격으로 이루어진다. 만약 시퀀서가 트랜잭션을
포함하지 않으면, 클라이언트는 지연된 인박스에 직접 게시하고 일정 시간 후
(아비트럼 원의 경우 약 24시간) \'강제 포함\'시킬 수 있다.

이 단계에서 트랜잭션은 이더리움과 동등한 수준의 최종성을 갖는다. 즉, L2
트랜잭션의 최종성은 이를 기록한 L1 트랜잭션의 최종성과 같다. 이는
아비트럼의 실행이 완전히 결정적이며, 인박스 컨트랙트가 L2 체인의 상태를
재구성하고 검증하기에 충분한 데이터를 보장하기 때문이다.

그 다음, 검증자가 이 트랜잭션을 포함하는 RBlock(롤업 블록)을 주장한다.
검증자는 아비트럼 VM을 실행하고 체인의 최신 상태에 대해 온체인 주장을
한다. 이는 보통 30-60분마다 이루어진다.

RBlock 주장이 유효하고 일주일의 이의 제기 기간 동안 아무도 이의를
제기하지 않으면, 그대로 확정된다. 만약 두 검증자가 서로 다른 RBlock을
주장하면 분쟁이 발생한다. 분쟁은 두 검증자가 차이를 하나의 L2 블록으로
좁히고, 그 안에서 단일 OPCODE까지 분해한 뒤, 이 연산을 실행하는 과정으로
이루어진다.

마지막으로, 모든 분쟁이 해결되고 충분한 시간이 지나면 RBlock이 L1에서
확인된다. 이때 L1의 아웃박스 루트가 업데이트된다.

 ## 시퀀서와 인터체인 메시징 ##

아비트럼의 시퀀서는 레이어 2 솔루션의 핵심 요소로, 트랜잭션 처리 과정을
효율적으로 관리하는 특별한 전체 노드다. 시퀀서의 주요 역할은 트랜잭션의
순서를 결정하고, 이를 빠르게 처리하는 것이다. 이를 통해 사용자는
이더리움 메인넷의 확인을 기다릴 필요 없이 즉각적인 트랜잭션 결과를 얻을
수 있다.

시퀀서의 작동 원리는 다음과 같다:

1.  트랜잭션 수신: 사용자가 서명한 트랜잭션을 시퀀서에 전송한다.

2.  순서 결정: 시퀀서는 받은 트랜잭션들을 순서대로 정렬한다.

3.  실행: 정렬된 트랜잭션들은 상태 전이 함수를 통해 순차적으로 처리된다.

4.  결과 반환: 처리 결과를 즉시 사용자에게 알려준다.

이 과정에서 시퀀서는 두 가지 방식으로 트랜잭션 시퀀스를 발행한다.

-----------------------------------------------------------------------

**트랜잭션 시퀀스 발행방식** 
---------------- ------------------------------------------------------

  **실시간 피드** : 구독자에게 각 트랜잭션이 순서화될 때마다 즉시 알림을
                   제공한다. 이는 \'Soft finality\'을 제공한다.

  **L1 배치 게시** : 주기적으로(보통 몇 분마다) 트랜잭션 그룹을 압축하여 이더리움에 콜데이터로 게시한다. 이는 \'hard finality\'를 보장한다.

시퀀서의 도입으로 인박스의 작동 방식도 변경되었다.

  -----------------------------------------------------------------------
  **변경 사항        설명**
  ---------------- ------------------------------------------------------
  
   **직접 메시지 태깅** : 구독자에게 각 트랜잭션이 순서화될 때마다 즉시 알림을
                   제공한다. 이는 \'Soft finality\'을 제공한다.

  **메시지 태깅** : 시퀀서는 제출하는 메시지에 이더리움 블록 번호와
                   타임스탬프를 태그한다.

  **지연된 인박스** : 비시퀀서 노드가 제출한 메시지는 L1 이더리움 컨트랙트가
                   관리하는 \"지연된 인박스\" 큐에 들어간다.                
  
  **메시지 릴리스** : 시퀀서는 지연된 메시지를 메인 인박스로 \"릴리스\"한다.
                   보통 10분 후에 이루어진다.
  
  **강제 승격** : 최대 지연 간격(현재 아비트럼 원에서 24시간) 이후에는
                   누구나 메시지를 메인 인박스로 강제 승격시킬 수 있다.
        
  -----------------------------------------------------------------------

정상 작동하는 시퀀서는 모든 요청자의 트랜잭션을 공정하게 처리하고,
약속된 트랜잭션 결과를 최대한 빨리 제공한다. 또한 지연된 메시지를 신속히
릴리스하여 비시퀀서 트랜잭션의 지연을 최소화한다. 예를 들어,
이더리움에서 최종성에 대한 충분한 확신을 갖기 위해 40개의 확인 블록이
필요하다고 판단하면, 40개 블록 후에 지연된 메시지를 릴리스한다.

아비트럼은 초기에 신뢰할 수 있는 당사자가 시퀀서를 운영하고 나중에
탈중앙화할 계획이기 때문에, 현재는 잘못 행동하는 시퀀서를 직접 제재하는
메커니즘을 구축하지 않았다.

시퀀서의 또 다른 중요한 브릿징 역할은 L1과 L2 간의 상호작용을 관리하는
것이다. L1과 L2 체인은 동시에 똑같이 진행되지 않으므로(주: 작업의 요청과
응답 타이밍이 같지 않아도 된다는 의미)크로스체인 호출 또한 다른 타이밍에
진행된다. 결과적으로 크로스 체인 컨트랙트 간 호출은, 처음 호출한 체인
내에서의 호출 컨트랙트에서 사용할 수 있는 결과를 생성할 수 없다.

현재 아비트럼 원과 노바 체인의 시퀀서는 오프체인 랩스에서 운영하고 있다.
하지만 장기적으로는 탈중앙화된 공정 시퀀싱으로 전환할 계획이다. 이는
단일 중앙화 서버 대신 서버 위원회가 시퀀서 역할을 하며, 위원회의 충분히
큰 과반수가 정직하다면 공정한 트랜잭션 순서를 보장하는 방식이다.
개발자들은 이러한 시퀀서의 작동 원리를 이해함으로써, 아비트럼
네트워크에서 더 효율적이고 안전한 애플리케이션을 개발할 수 있다. 특히
트랜잭션의 순서와 최종성, 그리고 L1과 L2 간의 상호작용에 대한 이해는
복잡한 dApp 개발에 큰 도움이 될 것이다.

## 가스비 (L1과 L2 가스비 설명 및 산출 방식)

아비트럼에서 사용자가 트랜잭션을 발생시키면 체인 운영 비용을 위해
수수료를 내야 한다. 이 수수료는 L2 단계에서 ArbOS가 계산하고 수집하며,
이더리움(ETH)으로 지불한다. 트랜잭션 수수료는 두 가지 요소로 구성된다:

1\. L2 가스: 니트로 체인에서 트랜잭션을 실행하는 데 필요한 가스량으로,
이더리움의 가스와 비슷한 개념이다.\
2. L1 콜데이터: 트랜잭션 데이터를 L1에 기록하는 비용으로, 시퀀서를 통해
처리된 트랜잭션에만 부과된다.

L2 가스 수수료는 이더리움의 가스비 계산 방식과 매우 유사하다. 트랜잭션이
사용하는 가스량에 현재의 기본 수수료를 곱해서 계산한다

L2 기본 수수료는 \'지수 메커니즘\'이라는 방식으로 결정된다. 이는
이더리움의 EIP-1559 가스 가격 책정 방식과 비슷한 원리다. 이 알고리즘은
\'속도 제한\'이라는 기준과 실제 가스 사용량을 비교한다. 속도 제한은
체인이 지속적으로 처리할 수 있는 초당 목표 가스량을 말한다. 현재
아비트럼 원의 속도 제한은 초당 700만 가스다. 알고리즘은 \'가스
백로그\'라는 것을 계속 추적한다. 트랜잭션이 가스를 쓸 때마다 이 백로그에
가스가 쌓이고, 매초마다 속도 제한만큼 백로그에서 빠진다. (단, 백로그가 0
미만으로 내려가지는 않는다.)

쉽게 말해, 백로그가 쌓이면 네트워크가 혼잡하다는 뜻이므로 가스 가격을
올려 사용을 줄인다. 반대로 백로그가 줄면 가격을 내려 더 많은 사용을
유도한다.

  -----------------------------------------------------------------------
  기본 수수료 계산 공식
  -----------------------------------------------------------------------
  **Fee = exp(-a(B-b))**

  ㄴ Fee: 기본 수수료

  ㄴ B : 현재 백로그

  ㄴ a, b : 조정 상수

  -----------------------------------------------------------------------

기본 수수료는 백로그를 바탕으로 한 수식으로 계산된다. 수식은 복잡해
보이지만, 본질적으로 백로그가 많을수록 수수료가 높아지는 구조다.\
\
L1 콜데이터 수수료는 아비트럼 트랜잭션 데이터를 이더리움에 기록하는
비용을 충당하기 위한 것이다. 시퀀서나 배치 포스터가 이 작업을 하면서
이더리움 가스비를 써야 하기 때문에 이를 보상하는 개념이다.시퀀서로
들어오는 모든 트랜잭션은 이 L1 콜데이터 수수료를 낸다. 반면 지연된
인박스를 통해 들어오는 트랜잭션은 이 수수료를 내지 않지만, 대신 인박스에
들어갈 때 이더리움에 직접 가스비를 낸다.

L1 가격 책정 알고리즘은 각 트랜잭션의 크기를 추정해 수수료를 계산한다.
트랜잭션 크기에 현재 바이트당 가격을 곱하고, 이를 다시 L2 가스 단위로
변환한다. 이렇게 계산된 수수료를 \'포스터 수수료\'라고 부른다.바이트당
가격은 실제 배치 포스터가 쓴 비용과 수집된 수수료를 비교해 조정된다.
수수료가 비용보다 적으면 가격을 올리고, 반대면 내린다.

결국 사용자가 내는 총 수수료는 **L2 기본 수수료에 (L2 가스 사용량 + L1
콜데이터 수수료)를 곱한 값**이다. 이더리움처럼 가스가 부족하거나 기본
수수료 한도가 너무 낮으면 트랜잭션이 실패한다. (다만 이더리움과 달리
니트로는 \'팁\' 기능은 없다.)

## Geth와 WAVM의 특징 및 차이점

![img1](images/image1.png)

Geth(go-ethereum)는 이더리움의 핵심 노드 소프트웨어로, Nitro 시스템의
기반이 된다. Nitro는 이 Geth를 중심으로 세 개의 주요 레이어로 구성되어
있다. 가장 아래에 있는 Geth Core 레이어는 이더리움 가상 머신(EVM) 계약
실행과 상태 데이터 구조 유지를 담당한다. Nitro는 이 부분을 라이브러리로
컴파일해 사용한다. 중간 레이어인 ArbOS는 Layer 2에 특화된 기능을
제공하는 맞춤 소프트웨어다. 여기서는 Sequencer 데이터 배치 처리, Layer 1
가스 비용 계산, 수수료 수집, 그리고 크로스체인 브릿지 기능 등을
지원한다. 맨 위의 Node Functionality 레이어는 주로 Geth에서 가져온
코드로 이뤄져 있으며, 클라이언트 연결과 RPC 요청 처리 등 이더리움 호환
블록체인 노드 운영에 필요한 고수준 기능을 제공한다.

이런 구조는 \"geth sandwich\"라고 불린다. Geth 코드가 위아래를 감싸고
있는 모양새를 띠기 때문이다. 상태 전이 함수(STF)는 Geth Core와 ArbOS의
일부로 구성되어 있다. 이 구조 덕분에 Arbitrum은 이더리움의 안정성과
호환성을 유지하면서도 Layer 2의 특화된 기능을 제공할 수 있다. 또한
Geth의 검증된 코드를 재사용함으로써 개발 효율성과 신뢰성을 높일 수 있다.

실용적인 롤업 시스템을 만드는 데 있어 주요 과제는 일반 실행에서의 높은
성능과 결과의 신뢰성 있는 증명 사이의 균형을 맞추는 것이다. 또한
효율적인 분쟁 해결 방법도 필요하다. 이런 과제들을 해결하기 위해
Arbitrum은 실행과 증명을 분리하는 접근법을 택했고, 이를 위해 WAVM이
등장했다.

WAVM은 WebAssembly를 기반으로 하지만, Arbitrum의 요구사항에 맞게 수정된
가상 머신이다. WAVM은 WebAssembly의 일부 기능을 제거하거나 제한하며,
부동 소수점 연산을 소프트웨어 라이브러리로 대체한다. 또한 제어 흐름
구조를 단순화하고 중첩된 제어 흐름을 없앤다. WAVM은 블록체인 환경과
상호작용을 위한 특별한 opcode를 추가하고, 실행 시간을 예측 가능하게
만들며, 효율적인 증명 생성과 검증에 최적화되어 있다.

Geth와 WAVM을 비교해보면 그 차이가 뚜렷하다. Geth는 실제 이더리움
네트워크 운영이 목적이지만, WAVM은 Arbitrum의 상태 전이 함수 증명에
특화되어 있다. Geth는 일반 컴퓨터에서 바로 실행되지만, WAVM은 특수한
증명 시스템 안에서 돌아간다. Geth는 이더리움 노드의 모든 기능을 제공하는
반면, WAVM은 증명에 필요한 제한된 기능만 제공한다. 성능 최적화 면에서
Geth는 일반적인 네트워크 운영에 맞춰져 있고, WAVM은 증명 생성과 검증에
최적화되어 있다. Geth는 플러그인으로 기능을 확장할 수 있지만, WAVM은
증명 목적에 맞게 확장성이 제한되어 있다. 실행 시간의 예측 가능성 면에서,
Geth는 실행 시간이 변할 수 있지만 WAVM은 모든 연산의 실행 시간을 정확히
알 수 있다. 마지막으로 이식성 면에서 Geth는 특정 플랫폼에 최적화될 수
있는 반면, WAVM은 플랫폼에 상관없이 같은 결과를 보장한다.

결론적으로, Geth는 이더리움 노드 운영에 필요한 모든 기능을 제공하는 범용
소프트웨어다. 반면 WAVM은 Arbitrum의 Layer 2 솔루션에서 효율적이고
신뢰할 수 있는 증명 시스템을 구현하기 위해 특별히 설계된, 제한적이고
특화된 실행 환경이다. 이 두 시스템을 함께 사용함으로써 Arbitrum은 높은
성능과 보안성을 동시에 달성할 수 있게 되었다.

## 스타일러스 SDK 개발 개요

스타일러스 SDK는 개발자들에게 강력하고 유연한 스마트 컨트랙트 개발
환경을 제공한다. 이 SDK의 핵심은 WebAssembly(WASM)를 기반으로 한 가상
머신을 이용해 다양한 프로그래밍 언어로 스마트 컨트랙트를 작성할 수 있게
하는 것이다.

우선 Rust 언어에 대한 지원이 가장 풍부하다. Rust용 스타일러스 SDK는
스마트 컨트랙트 개발에 필요한 모든 기능을 담고 있어, Rust로 스마트
컨트랙트를 작성하는 과정을 최대한 쉽고 효율적으로 만들어준다. 또한 C와
C++ 언어도 지원되어, 기존에 이 언어들로 작성된 코드를 최소한의 수정으로
블록체인에 올릴 수 있다.

스타일러스 SDK의 개발 과정은 크게 코딩, 컴파일, 실행, 증명의 네 단계로
나눌 수 있다. 개발자는 선호하는 언어로 코드를 작성한 뒤, 이를 WASM으로
컴파일한다. 컴파일된 WASM 코드는 블록체인에 올라가고, \'ArbWasm\'이라는
새로운 프리컴파일을 통해 노드의 네이티브 머신 코드로 변환된다. 이
과정에서 가스 계측, 깊이 검사, 메모리 과금 등 안전성을 위한 여러 절차가
진행된다.

스타일러스의 장점은 다음과 같다:

1.  다양한 언어 지원: Solidity 개발자가 2만 명 정도인 반면, Rust
     개발자는 300만 명, C 개발자는 1200만 명에 달한다. 스타일러스는
     이들이 익숙한 언어로 블록체인 개발에 참여할 수 있게 해준다.

2.  EVM+: 기존 EVM의 모든 장점을 유지하면서도, Rust, C, C++의 효율성과
     풍부한 라이브러리를 활용할 수 있다.

3.  저렴한 실행 비용: WASM 프로그램은 EVM보다 훨씬 효율적으로 실행되어,
     복잡한 스마트 컨트랙트의 가스 비용을 크게 줄일 수 있다. 계산
    비용은 최대 10배, 메모리 사용은 100배 이상 저렴해질 수 있다.

4.  향상된 보안: 재진입(reentrancy) 공격 같은 흔한 취약점에 대해 더 나은
    보호를 제공한다. Rust SDK에서는 기본적으로 재진입이 불가능하며,
    필요한 경우에만 명시적으로 허용할 수 있다.

5.  완벽한 상호운용성: Solidity로 작성된 프로그램과 WASM 프로그램은 서로
    완벽하게 호환된다. 개발자는 언어의 제약 없이 다른 컨트랙트를
    호출하거나 활용할 수 있다.

이러한 장점들로 인해 스타일러스는 기존에 EVM에서 구현하기 어려웠던
복잡한 연산이나 대규모 메모리 사용이 필요한 작업들을 가능하게 만든다.
예를 들어, 고급 암호화 알고리즘, 대규모 생성 예술, 복잡한 게임 로직,
연산 집약적인 AI 모델 등을 블록체인 상에서 구현할 수 있게 되었다.

결론적으로, 스타일러스 SDK는 블록체인 개발의 새로운 지평을 열어주고
있다. 더 많은 개발자들이 자신의 전문 분야를 블록체인에 접목시킬 수 있게
되었고, 이는 곧 더 혁신적이고 다양한 탈중앙화 애플리케이션의 등장으로
이어질 것이다.
