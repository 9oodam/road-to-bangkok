# 잔고 관리와 채굴자 보상 설정 실습

> 가제: UTXO 실습.

## 들어가며

블록체인 네트워크는 트랜잭션을 통해 상태를 변경하고 잔고를 추적합니다.
이전 모듈에서 트랜잭션 출력(TXO)과 사용된 TXO에 대해 알아보았다면, 이번 모듈에서는 트랜잭션을 할 때의 금액과 잔고 확인, 트랜잭션 성공, 채굴자 보상 설정까지 코드를 작성하면서 함께 살펴보도록 하겠습니다.

## 사전 준비

이번 실습에서는 CodeSandbox를 사용합니다.

먼저, [링크](http://??)를 클릭하여 CodeSandbox 페이지로 이동해주세요.

화면 우측 상단에 있는 [Sign In] 버튼을 클릭하여 로그인을 합니다.

TODO: 사진 추가

로그인이 완료되면, 제공된 코드를 CodeSandbox에서 자신의 프로젝트로 복제해줍니다.

그럼 이제부터는 자유롭게 코드를 수정할 수 있습니다.

## 실습 1. 금액과 잔고 확인

> **실습 목표:**
>
> 입력 UTXO의 총합이 출력 UTXO의 총합을 충당할 수 있는지 확인하고, 입력의 총합이 출력의 총합보다 작으면 실행 함수에서 에러를 던집니다.

비트코인 지갑 소프트웨어는 때때로 하나의 큰 UTXO로 합쳐 소유자에게 다시 보내기 위해 많은 입력 UTXO를 포함하도록 선택할 수 있습니다.

예를 들어, 각각 0.1 BTC의 금액을 가진 5개의 UTXO가 있다면 지갑은 다음 거래에서 이를 0.5 BTC로 합치도록 선택할 수 있습니다.

때문에 입력 UTXO의 총 가치가 출력 UTXO의 총 금액을 충당할 수 있을 만큼 충분한지 확인하는 것이 가장 중요합니다.

### 1단계: 코드 작성

### 2단계: 테스트

```javascript
// Transaction.js
class Transaction {
  constructor(inputUTXOs, outputUTXOs) {
    this.transactions = { inputUTXOs, outputUTXOs };
  }
  execute() {
    const isDoubleSpend = this.transactions.inputUTXOs.findIndex((utxo) => utxo.spent === true);

    if (isDoubleSpend !== -1) {
      throw new Error('input TXO is already spent.');
    }

    const totalInputAmount = this.transactions.inputUTXOs.reduce((acc, cur) => acc + cur.amount, 0);
    const totalOutputAmount = this.transactions.outputUTXOs.reduce((acc, cur) => acc + cur.amount, 0);

    if (totalInputAmount < totalOutputAmount) {
      throw new Error('insufficient amount: total value of the inputs is less than the total value of the outputs!');
    }
  }
}

module.exports = Transaction;
```

## 실습 2. 트랜잭션 성공

> **실습 목표:**
>
> 호호

트랜잭션이 성공하여 블록체인에 채굴되면, 출력 UTXO는 사용할 준비가 된 새로운 TXO가 됩니다.

입력된 UTXO는 다시 사용되지 않도록 사용됨으로 표시해야 합니다!

결국 블록체인의 전체 목적은 이중 지출 문제를 해결하는 것입니다 😉.

```javascript
class Transaction {
  constructor(inputUTXOs, outputUTXOs) {
    this.transactions = { inputUTXOs, outputUTXOs };
  }
  execute() {
    const isDoubleSpend = this.transactions.inputUTXOs.findIndex((utxo) => utxo.spent === true);

    if (isDoubleSpend !== -1) {
      throw new Error('input TXO is already spent.');
    }

    const prevInputUTXOs = [...this.transactions.inputUTXOs];
    const prevOutputUTXOs = [...this.transactions.outputUTXOs];

    const totalInputAmount = prevInputUTXOs.reduce((acc, cur) => acc + cur.amount, 0);
    const totalOutputAmount = prevOutputUTXOs.reduce((acc, cur) => acc + cur.amount, 0);

    if (totalInputAmount < totalOutputAmount) {
      throw new Error('insufficient amount!');
    }

    const newInputUTXOs = prevInputUTXOs.map((utxo) => (utxo.spent = true));

    this.transactions.inputUTXOs = newInputUTXOs;
  }
}

module.exports = Transaction;
```

## 실습 3. 채굴자 보상 설정

> **실습 목표:**
>
> 블라블라

이쯤 되면 왜 세 번째 단계에서 총 입력 금액이 총 출력 금액보다 많아야만 하는지 궁금하실 텐데요.

출력 금액이 더 적으면 오류를 던져야 하지 않을까요? 🤔

아닙니다! 사실, 나머지는 채굴자에게 주어집니다! ⛏️

이것은 비트코인 시스템의 설계상 선택입니다.

트랜잭션 수수료라고 하며, 트랜잭션 수수료는 요청을 신속하게 처리하는 데 도움이 될 수 있습니다.

채굴자가 수집할 수 있는 큰 상금을 포함하면 다음 블록에 트랜잭션을 포함할 가능성이 훨씬 더 높아집니다! 💰

> 📖 참고 사항
>
> 비트코인은 [공급이 통제](https://en.bitcoin.it/wiki/Controlled_supply)됩니다.
> 제한된 시간 동안 모든 블록에서 채굴자에게 보상이 주어집니다.
> 특정 시점이 되면 이 보상은 중단되고 채굴자에게 주어지는 유일한 보상은 거래 수수료가 됩니다.

`execute` 함수가 끝나면 수수료를 모든 입력값의 합계에서 모든 출력값의 합계를 뺀 값으로 계산합니다.
입력값이 부족하면 에러가 발생하므로 이 값은 최소 0이어야 합니다.
출력이 더 적을 때는 양수 수수료가 되어야 합니다.
수수료 금액은 트랜잭션의 수수료라는 프로퍼티에 저장합니다.

예시:

```javascript
const iTXO = new TXO(fromAddress, 5);
const oTXO = new TXO(toAddress, 3);

const tx = new Transaction([iTXO], [oTXO]);

tx.execute();

console.log(tx.fee); // 2
```

```javascript
class Transaction {
  constructor(inputUTXOs, outputUTXOs) {
    this.transactions = { inputUTXOs, outputUTXOs };
    this.fee = 0;
  }
  execute() {
    const isDoubleSpend = this.transactions.inputUTXOs.findIndex((utxo) => utxo.spent === true);

    if (isDoubleSpend !== -1) {
      throw new Error('input TXO is already spent.');
    }

    const prevInputUTXOs = [...this.transactions.inputUTXOs];
    const prevOutputUTXOs = [...this.transactions.outputUTXOs];

    const totalInputAmount = prevInputUTXOs.reduce((acc, cur) => acc + cur.amount, 0);
    const totalOutputAmount = prevOutputUTXOs.reduce((acc, cur) => acc + cur.amount, 0);

    if (totalInputAmount < totalOutputAmount) {
      throw new Error('insufficient amount!');
    }

    this.fee = totalInputAmount - totalOutputAmount;

    const newInputUTXOs = prevInputUTXOs.map((utxo) => (utxo.spent = true));

    this.transactions.inputUTXOs = newInputUTXOs;
  }
}

module.exports = Transaction;
```

## 나가며
